/* ================= package.json (for reference) =================
Put this JSON into your package.json if you prefer separate file.

{
  "name": "noahjo-shop-server",
  "version": "1.0.1",
  "private": true,
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "better-sqlite3": "^8.2.0",
    "bcrypt": "^5.1.0",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "stripe": "^12.0.0",
    "jsonwebtoken": "^9.0.0",
    "socket.io": "^4.7.2"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
=================================================================*/

/* ================= server.js (single-file app + init) ================= */
require('dotenv').config();
const fs = require('fs');
const path = require('path');
const express = require('express');
const cors = require('cors');
const Database = require('better-sqlite3');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const http = require('http');

const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY || '';
const STRIPE_WEBHOOK_SECRET = process.env.STRIPE_WEBHOOK_SECRET || ''; // optional in dev
const JWT_SECRET = process.env.JWT_SECRET || 'please-change-this';
const PORT = process.env.PORT || 3001;
const DB_FILE = process.env.DATABASE_FILE || path.join(__dirname, 'data', 'db.sqlite');

let stripe = null;
if (STRIPE_SECRET_KEY) {
  stripe = require('stripe')(STRIPE_SECRET_KEY);
}

/* ---------- ensure data dir and DB exists (init if missing) ---------- */
function initDbIfMissing(dbFilePath) {
  const DATA_DIR = path.dirname(dbFilePath);
  if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });

  if (fs.existsSync(dbFilePath)) {
    console.log('Database file exists:', dbFilePath);
    return;
  }

  console.log('Creating database and seeding data at', dbFilePath);
  const db = new Database(dbFilePath);
  db.pragma('journal_mode = WAL');
  db.pragma('foreign_keys = ON');

  // users
  db.exec(`
    CREATE TABLE users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      email TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      is_admin INTEGER DEFAULT 0,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );
  `);

  // products
  db.exec(`
    CREATE TABLE products (
      id TEXT PRIMARY KEY,
      title TEXT NOT NULL,
      category TEXT,
      price REAL NOT NULL,
      short_desc TEXT,
      long_desc TEXT,
      images TEXT DEFAULT '[]'
    );
  `);

  // reviews
  db.exec(`
    CREATE TABLE reviews (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      product_id TEXT NOT NULL,
      author_id INTEGER NOT NULL,
      author_email TEXT,
      rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
      text TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (product_id) REFERENCES products(id),
      FOREIGN KEY (author_id) REFERENCES users(id)
    );
  `);
  db.exec(`CREATE UNIQUE INDEX idx_one_review_per_user ON reviews(product_id, author_id);`);

  // orders
  db.exec(`
    CREATE TABLE orders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      stripe_session_id TEXT UNIQUE,
      user_id INTEGER,
      user_email TEXT,
      amount_total INTEGER,
      currency TEXT,
      status TEXT DEFAULT 'pending',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id)
    );
  `);

  // messages
  db.exec(`
    CREATE TABLE messages (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      order_id INTEGER NOT NULL,
      sender_id INTEGER,
      sender_role TEXT NOT NULL,
      text TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (order_id) REFERENCES orders(id),
      FOREIGN KEY (sender_id) REFERENCES users(id)
    );
  `);

  // seed products
  const products = [
    {
      id: 'prod-1', title: 'Nebula Headset', category: 'Accessories', price: 79.99,
      short_desc: 'Wireless gaming headset with spatial audio and nebula lighting.',
      long_desc: 'Immersive over-ear headset built for long sessions. 50mm drivers, low-latency wireless mode, breathable memory-foam cushions and subtle nebula RGB. Compatible with PC, console and mobile.',
      images: JSON.stringify(['/images/headset-1.jpg','/images/headset-2.jpg'])
    },
    {
      id: 'prod-2', title: 'Void Runner Hoodie', category: 'Apparel', price: 49.99,
      short_desc: 'Comfort-fit hoodie with glow-in-dark print.',
      long_desc: 'Premium cotton-blend hoodie featuring reflective galaxy print that glows under RGB lights. Relaxed fit, double-stitched seams and reinforced pocket.',
      images: JSON.stringify(['/images/hoodie-1.jpg'])
    },
    {
      id: 'prod-3', title: 'Meteor Grip', category: 'Accessories', price: 12.99,
      short_desc: 'Tactical phone grip inspired by meteor textures.',
      long_desc: 'Slim profile grip with anti-slip texture that looks like meteor rock. Attaches securely and supports wireless charging.',
      images: JSON.stringify(['/images/grip-1.jpg'])
    },
    {
      id: 'prod-4', title: 'Cosmo Lamp', category: 'Gear', price: 34.99,
      short_desc: 'Ambient lamp that projects soft galaxy patterns.',
      long_desc: 'Plugs into USB-C and casts a subtle rotating nebula across walls. Multiple brightness modes and silent motor.',
      images: JSON.stringify(['/images/lamp-1.jpg'])
    },
    {
      id: 'prod-5', title: 'Limited Star Coin', category: 'Collectibles', price: 199.0,
      short_desc: 'Numbered collector coin with enamel star inlay.',
      long_desc: 'Each coin is individually numbered and comes with a certificate of authenticity and a display capsule. 1 of 500.',
      images: JSON.stringify(['/images/coin-1.jpg'])
    },
    {
      id: 'prod-6', title: 'Orbit Flask', category: 'Accessories', price: 18.5,
      short_desc: 'Insulated flask with subtle nebula lacquer.',
      long_desc: 'Keeps drinks cold for 24 hours and hot for 12. Stainless steel interior and scratch-resistant finish.',
      images: JSON.stringify(['/images/flask-1.jpg'])
    }
  ];

  const insert = db.prepare('INSERT INTO products (id,title,category,price,short_desc,long_desc,images) VALUES (@id,@title,@category,@price,@short_desc,@long_desc,@images)');
  const insertMany = db.transaction((rows) => { for (const r of rows) insert.run(r); });
  insertMany(products);

  db.close();
  console.log('DB created and seeded.');
}

initDbIfMissing(DB_FILE);

/* ----------------- open DB ----------------- */
const db = new Database(DB_FILE, { readonly: false });
db.pragma('foreign_keys = ON');

/* ----------------- express app ----------------- */
const app = express();
// allow all origins for convenience; lock this down for production
app.use(cors());

/* Serve images from ./public/images */
app.use('/images', express.static(path.join(__dirname, 'public', 'images')));

/* ---------- WEBHOOK route must accept raw body BEFORE express.json ---------- */
app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
  if (!stripe) return res.status(400).send('Stripe not configured');

  const sig = req.headers['stripe-signature'];
  let event;

  try {
    if (STRIPE_WEBHOOK_SECRET) {
      // req.body is a Buffer
      event = stripe.webhooks.constructEvent(req.body, sig, STRIPE_WEBHOOK_SECRET);
    } else {
      // dev fallback: parse body buffer
      const text = req.body.toString();
      event = JSON.parse(text);
    }
  } catch (err) {
    console.error('Webhook signature verification failed.', err && err.message ? err.message : err);
    return res.status(400).send(`Webhook Error: ${err && err.message ? err.message : err}`);
  }

  // handle checkout.session.completed
  if (event.type === 'checkout.session.completed' || event.type === 'checkout.session.async_payment_succeeded') {
    const session = event.data.object;
    const stripeSessionId = session.id;
    const userId = session.metadata && session.metadata.user_id ? Number(session.metadata.user_id) : null;
    const amount_total = session.amount_total || null;
    const currency = session.currency || null;
    const customer_email = session.customer_details ? session.customer_details.email : (session.customer_email || null);

    try {
      const exists = db.prepare('SELECT id FROM orders WHERE stripe_session_id = ?').get(stripeSessionId);
      if (!exists) {
        const insert = db.prepare('INSERT INTO orders (stripe_session_id, user_id, user_email, amount_total, currency, status) VALUES (?, ?, ?, ?, ?, ?)');
        const info = insert.run(stripeSessionId, userId, customer_email, amount_total, currency, 'paid');
        const order = db.prepare('SELECT * FROM orders WHERE id = ?').get(info.lastInsertRowid);
        // emit to admins if socket.io is up
        try { if (typeof io !== 'undefined' && io) io.to('admins').emit('order:created', order); } catch (e) { /* ignore */ }
      }
    } catch (e) {
      console.error('Error inserting order from webhook', e);
    }
  }

  res.json({ received: true });
});

/* ---------- now parse JSON for normal routes ---------- */
app.use(express.json());

/* ---------- helper: signToken ---------- */
function signToken(user) {
  const payload = { id: user.id, email: user.email, is_admin: !!user.is_admin };
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });
}

/* ---------- auth middleware ---------- */
function authenticate(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing auth' });
  const token = auth.split(' ')[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    next();
  } catch (e) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

/* ---------- routes: auth ---------- */
app.post('/api/auth/register', async (req, res) => {
  const { email, password, makeAdmin } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
  try {
    const pwHash = await bcrypt.hash(password, 10);
    const stmt = db.prepare('INSERT INTO users (email, password_hash, is_admin) VALUES (?, ?, ?)');
    const info = stmt.run(email.toLowerCase(), pwHash, makeAdmin ? 1 : 0);
    const user = { id: info.lastInsertRowid, email: email.toLowerCase(), is_admin: makeAdmin ? 1 : 0 };
    const token = signToken(user);
    res.json({ token, user });
  } catch (err) {
    if (err && err.code === 'SQLITE_CONSTRAINT_UNIQUE') return res.status(400).json({ error: 'Email already in use' });
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
  const row = db.prepare('SELECT id,email,password_hash,is_admin FROM users WHERE email = ?').get(email.toLowerCase());
  if (!row) return res.status(400).json({ error: 'Invalid credentials' });
  const ok = await bcrypt.compare(password, row.password_hash);
  if (!ok) return res.status(400).json({ error: 'Invalid credentials' });
  const token = signToken(row);
  res.json({ token, user: { id: row.id, email: row.email, is_admin: !!row.is_admin } });
});

/* ---------- products ---------- */
app.get('/api/products', (req, res) => {
  const rows = db.prepare('SELECT id,title,category,price,short_desc,long_desc,images FROM products').all();
  const parsed = rows.map(r => ({ ...r, images: JSON.parse(r.images || '[]') }));
  res.json(parsed);
});

/* ---------- reviews ---------- */
app.get('/api/products/:id/reviews', (req, res) => {
  const productId = req.params.id;
  const rows = db.prepare('SELECT r.id, r.product_id, r.author_id, r.author_email, r.rating, r.text, r.created_at, u.email as author_email_actual FROM reviews r LEFT JOIN users u ON u.id = r.author_id WHERE r.product_id = ? ORDER BY r.created_at DESC').all(productId);
  res.json(rows);
});

app.post('/api/products/:id/reviews', authenticate, (req, res) => {
  const productId = req.params.id;
  const { rating, text } = req.body;
  const userId = req.user.id;
  const userEmail = req.user.email;
  if (!rating || rating < 1 || rating > 5) return res.status(400).json({ error: 'Rating 1-5 required' });

  const exist = db.prepare('SELECT id FROM reviews WHERE product_id = ? AND author_id = ?').get(productId, userId);
  if (exist) return res.status(400).json({ error: 'You already reviewed this product' });

  try {
    const stmt = db.prepare('INSERT INTO reviews (product_id, author_id, author_email, rating, text) VALUES (?, ?, ?, ?, ?)');
    const info = stmt.run(productId, userId, userEmail, rating, text || null);
    const row = db.prepare('SELECT * FROM reviews WHERE id = ?').get(info.lastInsertRowid);
    res.json(row);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Server error' });
  }
});

app.delete('/api/reviews/:id', authenticate, (req, res) => {
  const id = Number(req.params.id);
  const userId = req.user.id;
  const isAdmin = !!req.user.is_admin;
  const row = db.prepare('SELECT * FROM reviews WHERE id = ?').get(id);
  if (!row) return res.status(404).json({ error: 'Not found' });
  if (row.author_id !== userId && !isAdmin) return res.status(403).json({ error: 'Not authorized' });
  db.prepare('DELETE FROM reviews WHERE id = ?').run(id);
  res.json({ ok: true });
});

/* ---------- dev: promote user to admin ---------- */
app.post('/api/make-admin', authenticate, (req, res) => {
  const targetEmail = req.body.email;
  if (!req.user.is_admin) return res.status(403).json({ error: 'Only admins' });
  const row = db.prepare('SELECT id FROM users WHERE email = ?').get(targetEmail.toLowerCase());
  if (!row) return res.status(404).json({ error: 'User not found' });
  db.prepare('UPDATE users SET is_admin = 1 WHERE id = ?').run(row.id);
  res.json({ ok: true });
});

/* ---------- Stripe checkout ---------- */
app.post('/api/create-checkout-session', authenticate, async (req, res) => {
  if (!stripe) return res.status(500).json({ error: 'Stripe not configured. Set STRIPE_SECRET_KEY in env.' });
  const items = req.body.items;
  if (!items || !Array.isArray(items) || items.length === 0) return res.status(400).json({ error: 'No items' });

  const line_items = items.map(it => ({
    price_data: {
      currency: 'usd',
      product_data: { name: it.title },
      unit_amount: Math.round(it.price * 100)
    },
    quantity: it.qty || 1
  }));

  try {
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items,
      mode: 'payment',
      success_url: (process.env.APP_URL || 'http://localhost:3000') + '/success?session_id={CHECKOUT_SESSION_ID}',
      cancel_url: (process.env.APP_URL || 'http://localhost:3000') + '/cancel',
      metadata: { user_id: req.user.id }
    });
    res.json({ url: session.url });
  } catch (err) {
    console.error('stripe', err);
    res.status(500).json({ error: 'Stripe error' });
  }
});

/* ---------- orders ---------- */
app.get('/api/orders/mine', authenticate, (req, res) => {
  const rows = db.prepare('SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC').all(req.user.id);
  res.json(rows);
});

app.get('/api/orders', authenticate, (req, res) => {
  if (!req.user.is_admin) return res.status(403).json({ error: 'Only admins' });
  const rows = db.prepare('SELECT * FROM orders ORDER BY created_at DESC').all();
  res.json(rows);
});

app.get('/api/orders/by-session/:session', (req, res) => {
  const s = req.params.session;
  const row = db.prepare('SELECT * FROM orders WHERE stripe_session_id = ?').get(s);
  if (!row) return res.status(404).json({ error: 'Not found' });
  res.json(row);
});

/* ---------- messages ---------- */
app.get('/api/orders/:id/messages', authenticate, (req, res) => {
  const orderId = Number(req.params.id);
  const order = db.prepare('SELECT * FROM orders WHERE id = ?').get(orderId);
  if (!order) return res.status(404).json({ error: 'Order not found' });
  if (order.user_id !== req.user.id && !req.user.is_admin) return res.status(403).json({ error: 'Not authorized' });
  const rows = db.prepare('SELECT * FROM messages WHERE order_id = ? ORDER BY created_at ASC').all(orderId);
  res.json(rows);
});

/* ---------- start server + socket.io ---------- */
const server = http.createServer(app);
const { Server } = require('socket.io');
const io = new Server(server, { cors: { origin: '*' } });

io.use((socket, next) => {
  const token = socket.handshake.auth && socket.handshake.auth.token;
  if (!token) return next(new Error('Authentication error'));
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    socket.user = payload;
    return next();
  } catch (e) {
    return next(new Error('Authentication error'));
  }
});

io.on('connection', (socket) => {
  const user = socket.user;
  if (user.is_admin) socket.join('admins');

  socket.on('joinOrder', (orderId, cb) => {
    try {
      const order = db.prepare('SELECT * FROM orders WHERE id = ?').get(orderId);
      if (!order) return cb && cb({ error: 'Order not found' });
      if (order.user_id !== user.id && !user.is_admin) return cb && cb({ error: 'Not authorized' });
      const room = `order:${orderId}`;
      socket.join(room);
      const messages = db.prepare('SELECT * FROM messages WHERE order_id = ? ORDER BY created_at ASC').all(orderId);
      cb && cb({ ok: true, messages });
    } catch (err) {
      cb && cb({ error: 'Server error' });
    }
  });

  socket.on('message', (payload, cb) => {
    try {
      const { orderId, text } = payload;
      const order = db.prepare('SELECT * FROM orders WHERE id = ?').get(orderId);
      if (!order) return cb && cb({ error: 'Order not found' });
      if (order.user_id !== user.id && !user.is_admin) return cb && cb({ error: 'Not authorized' });
      const sender_role = user.is_admin ? 'admin' : 'user';
      const insert = db.prepare('INSERT INTO messages (order_id, sender_id, sender_role, text) VALUES (?, ?, ?, ?)');
      const info = insert.run(orderId, user.id, sender_role, text);
      const msg = db.prepare('SELECT * FROM messages WHERE id = ?').get(info.lastInsertRowid);
      const room = `order:${orderId}`;
      io.to(room).emit('message', msg);
      cb && cb({ ok: true, msg });
    } catch (err) {
      console.error('socket message error', err);
      cb && cb({ error: 'Server error' });
    }
  });

  socket.on('disconnect', () => { });
});

server.listen(PORT, () => console.log(`Server listening on ${PORT}`));


/* ================= README (Kurz) =================

How to run locally:
1) Create package.json (see top of this file), then:
   npm install
2) Put product images in ./public/images (create folder)
3) Create .env with:
   PORT=3001
   JWT_SECRET=some-long-random-secret
   STRIPE_SECRET_KEY=sk_test_...        (optional for checkout)
   STRIPE_WEBHOOK_SECRET=whsec_...     (optional; recommended when using stripe listen)
   APP_URL=http://localhost:3000
   DATABASE_FILE=./data/db.sqlite      (optional override)
4) Start:
   npm run dev   (if you have nodemon) or node server.js

Notes:
- The DB is auto-created and seeded the first time you run the server (if ./data/db.sqlite missing).
- For Stripe webhooks in dev: use `stripe listen --forward-to localhost:3001/webhook` and set STRIPE_WEBHOOK_SECRET to the printed signing secret.

Deploying to GitHub + Host (Railway / Render / Heroku):
1) Create a Git repo:
   git init
   git add .
   git commit -m "initial"
   git remote add origin <your-github-url>
   git push -u origin main

2) On hosting (Railway/Render):
   - Link GitHub repo or upload files.
   - Set environment variables in the host dashboard (STRIPE keys, JWT_SECRET, APP_URL, DATABASE_FILE path).
   - If the platform uses ephemeral disks (some do), ensure you use an attached persistent volume for ./data, or use a hosted DB; otherwise data (orders) can disappear on redeploy.

3) Stripe webhook:
   - In production, create a webhook endpoint in Stripe dashboard pointing to https://your-domain/webhook and copy the signing secret into STRIPE_WEBHOOK_SECRET.

Security reminders:
- Change JWT_SECRET before production.
- Lock CORS origin.
- Protect /api/make-admin endpoint or remove in production.
- Keep Stripe keys secret.

If du möchtest, kann ich:
- a) die package.json als separate Datei generieren,
- b) eine `.env.example` für dich schreiben,
- c) ein kurzes GitHub Actions workflow erstellen, das deployet (z. B. zu Heroku).

Sag mir kurz welche Option du willst — oder ich erstelle gleich `.env.example` + `package.json` für dich. 😊

================================================================= */
